1 事物并发所带来的问题
脏读 事物A读到事物B还没有提交的数据，这时如果B进行回滚，那么A读到的数据就是脏数据。(写只加共享锁带来的问题)
不可重复读 事物A多次读取统一数据，在事物A进行多次读取的过程中事物B对数据进行了修改并做了提交，导致事物A多次读取同一的数据时，结果不一致。(这种情况一般来说可以接受，因为读到的是B已经提交的数据，写不加锁带来的)
幻读 事物A多次读取同一范围的数据，在事物A多次读取同一范围的数据的时候，事物B在这个范围新增了一条数据或者删除了一条数据，导致事物A多次读取的数据的数目不一致，这时就出现了幻读。
幻读和不可重复读，都是在事物A进行多次读取时其他事务对数据进行了修改，但是又有区别，不可重复读是对数据的的内容进行了修改，而幻读是对数据的条目进行了修改。对于不可重复读可以在读取时加行锁，而可以通过加表锁来解决幻读。
2 事务隔离级别
为了有效的保证事物并发读取数据的正确性，提出了事务的隔离级别，其中锁的存在也是为了构建这种隔离级别。事务有四种隔离级别。
读未提交(read uncommitted)  允许脏读，也就是说这种隔离级可以读到其他事务未提交的数据。
读已提交(read committed) 只能读取到其他事务已经提交的数据。防止了脏读。但是可能出现不可重复读。读已提交使用的是一致性非锁定读，当一个事务要进行数据读取的时候，如果有另一个事务对该数据进行写操作，这时读操作并不会被阻塞，而是会读取一个快照数据(快照数据就是行数据的历史版本)。因为读操作读取的是行数据的当前版本，所以会出现不可重复读的问题。(一致性非锁定读总是读取被锁定行的最新一份快照)
可重复读(repeatable read) 解决不可重复读带来的问题，一个事务内查询到的数据都与开始时刻保持一致。可重复读的实现也是通过一致性非锁定读，即读快照数据(行数据的历史版本)。但是与读已提交读取快照数据的方式不同，一个事务中的所有读操作只会读取事务开始前行数据快照版本，所以解决了不可重复读问题。(一致性非锁定读总是读取事物开始时的行版本数据)
序列化(serializable) 每次读取需要获取表级锁，读写完全分离，解决了幻读的问题。
其中InnoDB默认使用RR级别，RR级别支持写操作的可串行化，支持BinLog的要求。同时也因为RR级别可以解决事物并发带来的三个问题，对于幻读，RR级别可以通过MVCC多版本控制解决，虽然序列化也能解决幻读的问题，但是序列化是通过给表加锁实现的，在多并发的情况下，并发很低。所以mysql默认使用RR级别。